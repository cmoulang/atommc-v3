/**
 * Copyright (c) 2021 Chris Moulang
 *
 * SPDX-License-Identifier: BSD-3-Clause
*/

.program test

.define public PIN_NB400 15
.define public PIN_1MHZ 4

;    set y, 0b1000
;    mov isr,y
;    push

.wrap_target
main_loop:
    wait 0 PIN PIN_1MHZ
    wait 0 PIN PIN_NB400 [4]

    in PINS 16              ; latch address
    jmp pin read            ; jmp if PIN_R_NW

write: // handle write, 6502 --> rp2040
    wait 1 PIN PIN_1MHZ    ; wait for clock
    wait 0 PIN PIN_1MHZ

    in PINS 16              ; latch and push data
    push noblock
    jmp main_loop [4]

read: // handle read, rp2040 --> 6502 
    in PINS 16              ; latch and push the address
    push noblock

    wait 1 PIN PIN_1MHZ     ; wait for clock

    set y,4                 ; flush the fifo
read_loop:
    pull noblock            ; get the next word (or x if tx FIFO empty)
    mov x, osr              ; save to x
    jmp y--, read_loop
                            ; osr = 0000FFxx 
    out pins, 8             ; output the value

                            ; osr = 000000FF 
    out pindirs, 8 [16]     ; Set data pin directions to out


    wait 0 PIN PIN_1MHZ     ; wait for clock
    
                            ; osr = 00000000
    out pindirs, 8  [4]     ; Restore data pin directions to in
.wrap


% c-sdk {
const uint GPIO_FIRST = 2;

// offset from GPIO_FIRST
const uint PIN_R_NW = 5;
const uint PIN_D0 = 6;
const uint PIN_A0 = 0;

void test_program_init(PIO pio, uint sm, uint offset) {
   pio_sm_config c = test_program_get_default_config(offset);
   sm_config_set_jmp_pin 	(&c, GPIO_FIRST + PIN_R_NW);  	
   sm_config_set_in_pins(&c, GPIO_FIRST);
   sm_config_set_out_pins(&c, GPIO_FIRST + PIN_D0, 8);
   //sm_config_set_in_shift(&c, true, true, 32);
   pio_sm_init(pio, sm, offset, &c);
}

%}
